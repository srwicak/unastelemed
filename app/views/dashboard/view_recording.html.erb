<div class="recording-container">
  <div class="recording-header">
    <h1>Data Pemeriksaan</h1>
    <div class="recording-info">
      <p><strong>Pasien:</strong> <%= @recording.patient.name %></p>
      <p><strong>Tanggal:</strong> <%= @recording.created_at.strftime('%d %B %Y %H:%M') %></p>
      <% if @recording.user %>
        <p><strong>Tenaga Medis:</strong> <%= @recording.user.name %></p>
      <% end %>
      <% if @session %>
        <% if @session.qr_code %>
          <p><strong>Kode Sesi:</strong> <%= @session.qr_code.code %></p>
        <% end %>
      <% end %>
    </div>
  </div>

  <div class="recording-content">
    <div class="chart-section">
      <h2>Grafik Data EKG</h2>
      
      <!-- ALWAYS show chart container, even if batches is empty or incomplete -->
      <div class="chart-info">
        <p><strong>Total Batches:</strong> <%= @batches.count %> <%= @batches.count > 0 ? "(showing first 100)" : "" %></p>
        <p><strong>Total Samples:</strong> <%= @recording.total_samples || 0 %></p>
        <p><strong>Sample Rate:</strong> 
          <% if @batches.any? %>
            <% rates = @batches.map(&:sample_rate).compact %>
            <% if rates.uniq.size == 1 %>
              <%= rates.first.round(1) %> Hz
            <% else %>
              <%= rates.min.round(1) %>-<%= rates.max.round(1) %> Hz (avg: <%= (rates.sum / rates.size).round(1) %> Hz)
            <% end %>
          <% else %>
            <%= @recording.sample_rate || 400 %> Hz
          <% end %>
        </p>
        <p><strong>Duration:</strong> <%= @recording.formatted_duration %></p>
        <% if @recording.data_status != :complete %>
          <p class="status-badge <%= @recording.data_status %>">
            <strong>Status:</strong> <%= @recording.data_status_message %>
          </p>
        <% end %>
      </div>
      
      <% if @batches.any? %>
        <!-- Has data - show chart -->
        <div class="chart-container">
          <canvas id="medicalChart" width="800" height="400"></canvas>
        </div>
        
        <!-- DEBUG PANEL - Temporary for troubleshooting -->
        <div id="debugPanel" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; font-family: monospace; font-size: 12px;">
          <h4 style="margin-top: 0;">üîç Debug Info (Temporary)</h4>
          <div id="debugInfo">
            <p><strong>JavaScript Variables:</strong></p>
            <pre id="jsVars" style="background: white; padding: 10px; border-radius: 3px; overflow-x: auto;"></pre>
            
            <p><strong>Chart Dataset:</strong></p>
            <pre id="chartData" style="background: white; padding: 10px; border-radius: 3px; max-height: 200px; overflow: auto;"></pre>
            
            <p><strong>Last API Response:</strong></p>
            <pre id="apiResponse" style="background: white; padding: 10px; border-radius: 3px; max-height: 300px; overflow: auto;"></pre>
            
            <p><strong>Loaded Ranges:</strong></p>
            <pre id="loadedRanges" style="background: white; padding: 10px; border-radius: 3px; overflow-x: auto;"></pre>
          </div>
        </div>
      <% else %>
        <!-- No data yet - show placeholder with helpful message -->
        <div class="no-data-placeholder">
          <div class="placeholder-chart">
            <canvas id="medicalChart" width="800" height="400"></canvas>
          </div>
          <div class="overlay-message">
            <% if @recording.status == 'recording' %>
              <div class="status-icon rotating">‚è≥</div>
              <h3>Menunggu Data dari Mobile App...</h3>
              <p>Grafik akan muncul otomatis setelah batch pertama diterima (¬±10 detik)</p>
              <div class="auto-refresh-indicator">
                <span class="pulse-dot"></span>
                Auto-refresh setiap 10 detik
              </div>
            <% elsif @recording.data_status == :no_data %>
              <div class="status-icon">‚ö†Ô∏è</div>
              <h3>Data EKG Tidak Tersedia</h3>
              <div class="error-details">
                <p><strong>Kemungkinan Penyebab:</strong></p>
                <ul>
                  <li>Mobile app tidak mengirim data batch selama recording</li>
                  <li>Koneksi internet terputus saat recording</li>
                  <li>Perangkat kehabisan baterai sebelum data terkirim</li>
                  <li>Recording dihentikan sebelum batch pertama dikirim</li>
                </ul>
                
                <p><strong>Informasi Recording:</strong></p>
                <ul>
                  <li>Status: <span class="badge badge-<%= @recording.status %>"><%= @recording.status.titleize %></span></li>
                  <li>Waktu Mulai: <%= @recording.start_time&.strftime('%d %B %Y %H:%M:%S') || 'N/A' %></li>
                  <li>Waktu Selesai: <%= @recording.end_time&.strftime('%d %B %Y %H:%M:%S') || 'N/A' %></li>
                  <li>Durasi: <%= @recording.formatted_duration %></li>
                </ul>
                
                <div class="action-hint">
                  <p><strong>üí° Saran:</strong></p>
                  <ul>
                    <li>Lakukan recording ulang untuk mendapatkan data yang lengkap</li>
                    <li>Pastikan mobile app sudah update ke versi terbaru</li>
                    <li>Pastikan koneksi internet stabil selama recording</li>
                    <li>Pastikan perangkat memiliki baterai cukup</li>
                  </ul>
                </div>
              </div>
            <% else %>
              <div class="status-icon">üìä</div>
              <h3>Belum Ada Data</h3>
              <p>Menunggu data dari perangkat...</p>
            <% end %>
          </div>
        </div>
      <% end %>
    </div>

    <% if @session && @interpretation.present? %>
      <div class="interpretation-section">
        <h2>Interpretasi Dokter</h2>
        <div class="interpretation-card">
          <% if @session.medical_staff %>
            <p class="doctor-info">Dr. <%= @session.medical_staff.name %></p>
          <% end %>
          
          <% if @session.diagnosis.present? %>
            <div class="interpretation-item">
              <h3>Diagnosis</h3>
              <p><%= @session.diagnosis %></p>
            </div>
          <% end %>
          
          <div class="interpretation-item">
            <h3>Catatan</h3>
            <p><%= @interpretation %></p>
          </div>
          
          <% if @session.recommendations.present? %>
            <div class="interpretation-item">
              <h3>Rekomendasi</h3>
              <p><%= @session.recommendations %></p>
            </div>
          <% end %>
        </div>
      </div>
    <% elsif @session && (current_user.medical_staff&.doctor?) %>
      <div class="add-interpretation-section">
        <h2>Tambahkan Interpretasi</h2>
        <%= form_with url: add_interpretation_path, method: :post, local: true do |f| %>
          <%= hidden_field_tag :id, @session.id %>
          
          <div class="form-group">
            <%= f.label :diagnosis, "Diagnosis" %>
            <%= f.text_area :diagnosis, class: "form-control", rows: 2, required: true %>
          </div>
          
          <div class="form-group">
            <%= f.label :doctor_notes, "Catatan Dokter" %>
            <%= f.text_area :doctor_notes, class: "form-control", rows: 4, required: true %>
          </div>
          
          <div class="form-group">
            <%= f.label :recommendations, "Rekomendasi" %>
            <%= f.text_area :recommendations, class: "form-control", rows: 3 %>
          </div>
          
          <div class="form-actions">
            <%= f.submit "Simpan Interpretasi", class: "btn btn-success" %>
          </div>
        <% end %>
      </div>
    <% else %>
      <div class="waiting-interpretation">
        <p>Hasil pemeriksaan sedang dalam proses interpretasi oleh dokter.</p>
      </div>
    <% end %>
  </div>

  <div class="recording-actions">
    <%= link_to "Kembali", :back, class: "btn btn-secondary" %>
    <% if current_user.medical_staff %>
      <%= link_to "Dashboard", dashboard_path, class: "btn btn-outline" %>
    <% else %>
      <%= link_to "Dashboard Pasien", patient_dashboard_path, class: "btn btn-outline" %>
    <% end %>
    <button onclick="exportChart()" class="btn btn-primary">Ekspor Grafik</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.0"></script>

<div id="annotationModal" class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <h3>Tambah Anotasi</h3>
    <form id="annotationForm">
      <div class="form-group">
        <label>Tipe Marker:</label>
        <div style="display: flex; gap: 12px;">
          <label style="display: flex; align-items: center; gap: 4px;">
            <input type="radio" name="markerType" value="point" checked>
            <span>Titik (Point)</span>
          </label>
          <label style="display: flex; align-items: center; gap: 4px;">
            <input type="radio" name="markerType" value="range">
            <span>Range (Interval)</span>
          </label>
        </div>
      </div>
      
      <div class="form-group">
        <label for="startTimeSeconds">Waktu Mulai (detik):</label>
        <input type="number" id="startTimeSeconds" class="form-control" step="0.001" min="0" required placeholder="Contoh: 5.250">
        <small style="color: #6c757d;">Format: detik dari awal recording</small>
      </div>
      
      <div class="form-group" id="endTimeGroup" style="display: none;">
        <label for="endTimeSeconds">Waktu Akhir (detik):</label>
        <input type="number" id="endTimeSeconds" class="form-control" step="0.001" min="0" placeholder="Contoh: 8.500">
        <small style="color: #6c757d;">Opsional untuk marker range</small>
      </div>
      
      <div class="form-group">
        <label for="annotationLabel">Label / Kategori</label>
        <select id="annotationLabel" class="form-control" required>
          <option value="">-- Pilih Label --</option>
          <option value="Aritmia">Aritmia</option>
          <option value="Noise">Noise / Gangguan</option>
          <option value="Artifact">Artifact</option>
          <option value="Normal">Normal</option>
          <option value="Abnormal QRS">Abnormal QRS</option>
          <option value="ST Elevation">ST Elevation</option>
          <option value="ST Depression">ST Depression</option>
          <option value="T Wave">T Wave Abnormality</option>
          <option value="Lainnya">Lainnya</option>
        </select>
      </div>
      
      <div class="form-group">
        <label for="annotationNotes">Catatan Tambahan</label>
        <textarea id="annotationNotes" class="form-control" rows="3" placeholder="Deskripsi detail..."></textarea>
      </div>
      
      <div class="form-actions">
        <button type="button" onclick="closeModal()" class="btn btn-secondary">Batal</button>
        <button type="submit" class="btn btn-primary">Simpan Anotasi</button>
      </div>
    </form>
  </div>
</div>

<script>
// Configuration
const RECORDING_ID = <%= @recording.id %>;
const START_TIME = new Date("<%= (@recording.start_time || @recording.created_at).iso8601 %>").getTime();
// For active recordings without end_time, use current time or last batch timestamp
<% if @recording.end_time %>
const RECORDING_END_TIME = new Date("<%= @recording.end_time.iso8601 %>").getTime();
<% elsif @batches.any? %>
const RECORDING_END_TIME = new Date("<%= @batches.last.end_timestamp.iso8601 %>").getTime();
<% else %>
const RECORDING_END_TIME = Date.now(); // Use current time as temporary end
<% end %>
const TOTAL_DURATION = RECORDING_END_TIME - START_TIME;
const INITIAL_WINDOW = 10 * 1000; // 10 seconds
const BUFFER_SIZE = 20 * 1000; // Keep 20s buffer on each side
const IS_RECORDING = <%= @recording.status == 'recording' ? 'true' : 'false' %>;
const HAS_DATA = <%= @batches.any? ? 'true' : 'false' %>;

// State
let currentChart = null;
let isLoading = false;
let isAnnotationMode = false;
let isDragging = false;
let dragStartX = null;
let dragStartTime = null;
let dragEndTime = null;
let selectionBox = null;
let annotations = [];
let loadedRanges = []; // Array of {start, end}
let dataCache = {}; // Cache loaded data by time range key
let lastDataFetch = 0; // Timestamp of last fetch

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  initChart();
  
  // Update debug panel on load
  updateDebugPanel();
  
  // Only fetch data if we have batches
  if (HAS_DATA) {
    const initialEnd = Math.min(START_TIME + INITIAL_WINDOW, RECORDING_END_TIME);
    console.log('üöÄ Initiating data fetch:', {
      START_TIME: new Date(START_TIME).toISOString(),
      initialEnd: new Date(initialEnd).toISOString(),
      INITIAL_WINDOW: INITIAL_WINDOW + 'ms'
    });
    fetchDataBuffered(START_TIME, initialEnd);
    fetchAnnotations();
  } else {
    // Show empty chart with grid
    updateChartData({ type: 'empty', data: [] }, START_TIME);
  }
  
  setupControls();
  setupDragSelection();
  
  document.getElementById('annotationForm').onsubmit = saveAnnotation;
  
  // Toggle end time field based on marker type
  document.querySelectorAll('input[name="markerType"]').forEach(radio => {
    radio.addEventListener('change', function() {
      const endTimeGroup = document.getElementById('endTimeGroup');
      if (this.value === 'range') {
        endTimeGroup.style.display = 'block';
      } else {
        endTimeGroup.style.display = 'none';
        document.getElementById('endTimeSeconds').value = '';
      }
    });
  });
  
  // Auto-refresh if recording is active
  if (IS_RECORDING) {
    startAutoRefresh();
  }
});

// Debug panel update function
function updateDebugPanel() {
  const debugPanel = document.getElementById('debugPanel');
  if (!debugPanel) return; // Panel might not exist if no batches
  
  // JavaScript variables
  document.getElementById('jsVars').textContent = JSON.stringify({
    RECORDING_ID,
    START_TIME: new Date(START_TIME).toISOString(),
    RECORDING_END_TIME: new Date(RECORDING_END_TIME).toISOString(),
    TOTAL_DURATION: (TOTAL_DURATION / 1000).toFixed(2) + 's',
    IS_RECORDING,
    HAS_DATA,
    isLoading,
    cacheKeys: Object.keys(dataCache).length
  }, null, 2);
  
  // Chart dataset
  if (currentChart && currentChart.data.datasets[0]) {
    const data = currentChart.data.datasets[0].data;
    const sample = data.slice(0, 10); // First 10 points
    document.getElementById('chartData').textContent = 
      `Total Points: ${data.length}\n\n` +
      `First 10 points:\n${JSON.stringify(sample, null, 2)}\n\n` +
      (data.length > 10 ? `Last point: ${JSON.stringify(data[data.length - 1], null, 2)}` : '');
  } else {
    document.getElementById('chartData').textContent = 'Chart not initialized or no data';
  }
  
  // Loaded ranges
  document.getElementById('loadedRanges').textContent = JSON.stringify(
    loadedRanges.map(r => ({
      start: new Date(r.start).toISOString(),
      end: new Date(r.end).toISOString(),
      duration: ((r.end - r.start) / 1000).toFixed(2) + 's'
    })),
    null,
    2
  );
}

function setupControls() {
  const controlsDiv = document.querySelector('.chart-controls') || createControlsDiv();
  controlsDiv.innerHTML = '';
  
  const resetBtn = document.createElement('button');
  resetBtn.className = 'btn btn-secondary btn-sm';
  resetBtn.innerText = 'Reset View';
  resetBtn.onclick = resetZoom;
  resetBtn.style.marginRight = '10px';
  
  const annotateBtn = document.createElement('button');
  annotateBtn.className = 'btn btn-outline btn-sm';
  annotateBtn.id = 'annotateBtn';
  annotateBtn.innerText = 'Mode Anotasi: OFF';
  annotateBtn.onclick = toggleAnnotationMode;
  annotateBtn.style.marginRight = '10px';
  
  const manualAnnotateBtn = document.createElement('button');
  manualAnnotateBtn.className = 'btn btn-outline btn-sm';
  manualAnnotateBtn.innerText = '+ Tambah Anotasi Manual';
  manualAnnotateBtn.onclick = () => openModal(0);
  manualAnnotateBtn.style.marginRight = '10px';
  
  const listAnnotationsBtn = document.createElement('button');
  listAnnotationsBtn.className = 'btn btn-outline btn-sm';
  listAnnotationsBtn.innerText = 'üìã Lihat Daftar Anotasi';
  listAnnotationsBtn.onclick = showAnnotationsList;
  
  controlsDiv.appendChild(resetBtn);
  controlsDiv.appendChild(annotateBtn);
  controlsDiv.appendChild(manualAnnotateBtn);
  controlsDiv.appendChild(listAnnotationsBtn);
}

function createControlsDiv() {
  const div = document.createElement('div');
  div.className = 'chart-controls';
  div.style.marginBottom = '10px';
  document.querySelector('.chart-container').before(div);
  return div;
}

// Custom EKG Grid Plugin
const ekgGridPlugin = {
  id: 'ekgGrid',
  beforeDraw: (chart) => {
    const ctx = chart.ctx;
    const chartArea = chart.chartArea;
    const yScale = chart.scales.y;
    const xScale = chart.scales.x;
    
    // Background color (pink like EKG paper)
    ctx.fillStyle = '#fff5f5';
    ctx.fillRect(chartArea.left, chartArea.top, 
                 chartArea.right - chartArea.left, 
                 chartArea.bottom - chartArea.top);
    
    // Calculate grid spacing
    // Y-axis: 10mm/mV, so 0.1mV per small square
    const smallSquareY = 0.1; // mV
    const largeSquareY = 0.5; // mV (5 small squares)
    
    // X-axis: 25mm/sec, so 0.04s per small square
    const smallSquareX = 0.04; // seconds
    const largeSquareX = 0.2; // seconds (5 small squares)
    
    // Draw small grid (1mm squares)
    ctx.strokeStyle = '#ffcccc';
    ctx.lineWidth = 0.5;
    
    // Vertical lines (time)
    const xMin = xScale.min;
    const xMax = xScale.max;
    for (let x = Math.floor(xMin / smallSquareX) * smallSquareX; 
         x <= xMax; 
         x += smallSquareX) {
      const pixel = xScale.getPixelForValue(x);
      ctx.beginPath();
      ctx.moveTo(pixel, chartArea.top);
      ctx.lineTo(pixel, chartArea.bottom);
      ctx.stroke();
    }
    
    // Horizontal lines (voltage)
    const yMin = yScale.min;
    const yMax = yScale.max;
    for (let y = Math.floor(yMin / smallSquareY) * smallSquareY; 
         y <= yMax; 
         y += smallSquareY) {
      const pixel = yScale.getPixelForValue(y);
      ctx.beginPath();
      ctx.moveTo(chartArea.left, pixel);
      ctx.lineTo(chartArea.right, pixel);
      ctx.stroke();
    }
    
    // Draw large grid (5mm squares)
    ctx.strokeStyle = '#ff9999';
    ctx.lineWidth = 1.0;
    
    // Vertical lines
    for (let x = Math.floor(xMin / largeSquareX) * largeSquareX; 
         x <= xMax; 
         x += largeSquareX) {
      const pixel = xScale.getPixelForValue(x);
      ctx.beginPath();
      ctx.moveTo(pixel, chartArea.top);
      ctx.lineTo(pixel, chartArea.bottom);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = Math.floor(yMin / largeSquareY) * largeSquareY; 
         y <= yMax; 
         y += largeSquareY) {
      const pixel = yScale.getPixelForValue(y);
      ctx.beginPath();
      ctx.moveTo(chartArea.left, pixel);
      ctx.lineTo(chartArea.right, pixel);
      ctx.stroke();
    }
  }
};

function initChart() {
  const ctx = document.getElementById('medicalChart').getContext('2d');
  
  currentChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [{
        label: 'EKG Signal (mV)',
        data: [],
        borderColor: '#000000',
        backgroundColor: 'transparent',
        borderWidth: 1.5,
        tension: 0,
        pointRadius: 0,
        fill: false,
        spanGaps: false
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      parsing: false,
      normalized: true,
      onClick: handleChartClick,
      scales: {
        x: {
          type: 'linear',
          min: 0,
          max: 10,
          title: { 
            display: true, 
            text: 'Waktu (detik) - Kecepatan: 25mm/detik',
            font: { size: 12, weight: 'bold' }
          },
          ticks: {
            stepSize: 1,
            callback: function(value) {
              return value.toFixed(1) + 's';
            }
          },
          grid: {
            display: false
          }
        },
        y: {
          min: -2.0,
          max: 2.0,
          title: { 
            display: true, 
            text: 'Amplitudo (mV) - Skala: 10mm/mV',
            font: { size: 12, weight: 'bold' }
          },
          ticks: {
            stepSize: 0.5,
            callback: function(value) {
              return value.toFixed(1) + ' mV';
            }
          },
          grid: {
            display: false
          }
        }
      },
      plugins: {
        zoom: {
          limits: {
            x: { min: 0, max: 3600 },
            y: { min: -2.0, max: 2.0 }
          },
          pan: {
            enabled: true,
            mode: 'x',
            onPanComplete: handlePanZoom
          },
          zoom: {
            wheel: { enabled: true },
            pinch: { enabled: true },
            mode: 'x',
            onZoomComplete: handlePanZoom
          }
        },
        annotation: { annotations: {} },
        tooltip: { enabled: true, mode: 'index', intersect: false }
      }
    },
    plugins: [ekgGridPlugin]
  });
}

// Debounced handler for pan/zoom
const handlePanZoom = debounce(function({chart}) {
  const {min, max} = chart.scales.x;
  checkBuffer(min, max);
}, 100);

function checkBuffer(visibleStartSec, visibleEndSec) {
  // Convert seconds to milliseconds for API calls
  const visibleStartMs = START_TIME + (visibleStartSec * 1000);
  const visibleEndMs = START_TIME + (visibleEndSec * 1000);
  
  const bufferSizeMs = BUFFER_SIZE;
  const desiredStartMs = Math.max(START_TIME, visibleStartMs - bufferSizeMs);
  const desiredEndMs = Math.min(RECORDING_END_TIME, visibleEndMs + bufferSizeMs);
  
  // Check if desired range is covered by ANY loaded range
  const isCovered = loadedRanges.some(r => r.start <= desiredStartMs && r.end >= desiredEndMs);
  
  if (!isCovered) {
    fetchDataBuffered(desiredStartMs, desiredEndMs);
  }
}

async function fetchDataBuffered(startTimeMs, endTimeMs) {
  console.log('üì• fetchDataBuffered called:', {
    startTimeMs: new Date(startTimeMs).toISOString(),
    endTimeMs: new Date(endTimeMs).toISOString(),
    isLoading
  });
  
  if (isLoading) {
    console.log('‚è∏Ô∏è Already loading, skipping...');
    return;
  }
  
  // Check cache first
  const cacheKey = `${startTimeMs}_${endTimeMs}`;
  if (dataCache[cacheKey]) {
    console.log('üíæ Using cached data for', cacheKey);
    updateChartData(dataCache[cacheKey], startTimeMs);
    return;
  }
  
  // Throttle requests (min 200ms between fetches)
  const now = Date.now();
  if (now - lastDataFetch < 200) {
    console.log('‚è±Ô∏è Throttling data fetch (last fetch:', now - lastDataFetch, 'ms ago)');
    return;
  }
  
  isLoading = true;
  lastDataFetch = now;
  
  try {
    const startIso = new Date(startTimeMs).toISOString();
    const endIso = new Date(endTimeMs).toISOString();
    
    console.log('üåê Fetching data from API:', {
      recording_id: RECORDING_ID,
      start_time: startIso,
      end_time: endIso,
      url: `/recordings/${RECORDING_ID}/data?start_time=${startIso}&end_time=${endIso}`
    });
    
    const response = await fetch(`/recordings/${RECORDING_ID}/data?start_time=${startIso}&end_time=${endIso}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.json();
    
    console.log('‚úÖ Received data:', result);
    
    // Update API response in debug panel
    if (document.getElementById('apiResponse')) {
      document.getElementById('apiResponse').textContent = JSON.stringify(result, null, 2);
    }
    
    // Cache the result
    dataCache[cacheKey] = result;
    
    // Update loaded ranges (merge, don't replace)
    const newRange = {start: startTimeMs, end: endTimeMs};
    const overlaps = loadedRanges.some(r => 
      (newRange.start >= r.start && newRange.start <= r.end) ||
      (newRange.end >= r.start && newRange.end <= r.end) ||
      (newRange.start <= r.start && newRange.end >= r.end)
    );
    
    if (!overlaps) {
      loadedRanges.push(newRange);
      // Sort and merge adjacent ranges
      loadedRanges.sort((a, b) => a.start - b.start);
      const merged = [];
      for (const range of loadedRanges) {
        if (merged.length === 0 || merged[merged.length - 1].end < range.start) {
          merged.push(range);
        } else {
          merged[merged.length - 1].end = Math.max(merged[merged.length - 1].end, range.end);
        }
      }
      loadedRanges = merged;
    }
    
    updateChartData(result, startTimeMs);
  } catch (error) {
    console.error('‚ùå Error fetching data:', error);
    
    // Update debug panel with error
    if (document.getElementById('apiResponse')) {
      document.getElementById('apiResponse').textContent = 
        'ERROR: ' + error.message + '\n\n' +
        'Stack: ' + error.stack;
    }
  } finally {
    isLoading = false;
    updateDebugPanel();
  }
}

function updateChartData(result, startTimeMs) {
  if (!currentChart) return;
  
  console.log('updateChartData called with:', {
    type: result.type,
    dataLength: result.data?.length,
    firstPoint: result.data?.[0],
    lastPoint: result.data?.[result.data.length - 1],
    START_TIME: START_TIME
  });
  
  let newData = [];
  
  if (result.type === 'empty') {
    // Empty data - keep existing data, don't clear
    console.log('Empty result, keeping existing data');
    return;
  } else if (result.type === 'summary') {
    result.data.forEach(d => {
      // Convert timestamp to seconds from recording start
      const seconds = (d.t - START_TIME) / 1000;
      newData.push({ x: seconds, y: d.min });
      newData.push({ x: seconds, y: d.max });
    });
  } else if (result.type === 'raw') {
    // Server sends {x: timestamp_ms, y: value}
    result.data.forEach(d => {
      const seconds = (d.x - START_TIME) / 1000;
      newData.push({ x: seconds, y: d.y });
    });
  }
  
  if (newData.length === 0) {
    console.log('No new data to add');
    return;
  }
  
  // Merge with existing data instead of replacing
  const existingData = currentChart.data.datasets[0].data || [];
  const allData = [...existingData, ...newData];
  
  // Remove duplicates based on x value (timestamp)
  const uniqueData = [];
  const seenX = new Set();
  for (const point of allData) {
    const key = Math.round(point.x * 1000); // Round to millisecond precision
    if (!seenX.has(key)) {
      seenX.add(key);
      uniqueData.push(point);
    }
  }
  
  // Sort by x (time)
  uniqueData.sort((a, b) => a.x - b.x);
  
  console.log('After conversion and merge:', {
    newDataLength: newData.length,
    existingDataLength: existingData.length,
    mergedLength: uniqueData.length,
    firstPoint: uniqueData[0],
    lastPoint: uniqueData[uniqueData.length - 1],
    sampleMiddle: uniqueData[Math.floor(uniqueData.length / 2)]
  });
  
  currentChart.data.datasets[0].data = uniqueData;
  currentChart.update('none');
  
  console.log('Chart updated. Total dataset length:', currentChart.data.datasets[0].data.length);
  
  // Update debug panel after chart update
  updateDebugPanel();
}

function toggleAnnotationMode() {
  isAnnotationMode = !isAnnotationMode;
  const btn = document.getElementById('annotateBtn');
  if (isAnnotationMode) {
    btn.innerText = 'üéØ Mode Anotasi: ON (Klik/Drag di grafik)';
    btn.classList.remove('btn-outline');
    btn.classList.add('btn-primary');
    document.getElementById('medicalChart').style.cursor = 'crosshair';
    currentChart.options.plugins.zoom.pan.enabled = false;
    currentChart.options.plugins.zoom.zoom.wheel.enabled = false;
    currentChart.options.plugins.zoom.zoom.pinch.enabled = false;
  } else {
    btn.innerText = 'Mode Anotasi: OFF';
    btn.classList.remove('btn-primary');
    btn.classList.add('btn-outline');
    document.getElementById('medicalChart').style.cursor = 'default';
    currentChart.options.plugins.zoom.pan.enabled = true;
    currentChart.options.plugins.zoom.zoom.wheel.enabled = true;
    currentChart.options.plugins.zoom.zoom.pinch.enabled = true;
  }
  currentChart.update('none');
}

function handleChartClick(event, elements, chart) {
  // Click handled by drag system now
}

function setupDragSelection() {
  const canvas = document.getElementById('medicalChart');
  
  canvas.addEventListener('mousedown', function(e) {
    if (!isAnnotationMode) return;
    
    isDragging = true;
    const rect = canvas.getBoundingClientRect();
    dragStartX = e.clientX - rect.left;
    
    const canvasPos = Chart.helpers.getRelativePosition(e, currentChart);
    const xScale = currentChart.scales.x;
    dragStartTime = xScale.getValueForPixel(canvasPos.x);
    dragEndTime = null;
    
    // Create selection box element
    if (!selectionBox) {
      selectionBox = document.createElement('div');
      selectionBox.style.position = 'absolute';
      selectionBox.style.border = '2px dashed #667eea';
      selectionBox.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
      selectionBox.style.pointerEvents = 'none';
      selectionBox.style.zIndex = '100';
      canvas.parentElement.style.position = 'relative';
      canvas.parentElement.appendChild(selectionBox);
    }
    
    selectionBox.style.display = 'none';
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (!isDragging || !isAnnotationMode) return;
    
    const rect = canvas.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    
    const canvasPos = Chart.helpers.getRelativePosition(e, currentChart);
    const xScale = currentChart.scales.x;
    dragEndTime = xScale.getValueForPixel(canvasPos.x);
    
    // Update selection box
    const left = Math.min(dragStartX, currentX);
    const width = Math.abs(currentX - dragStartX);
    
    const chartArea = currentChart.chartArea;
    selectionBox.style.left = left + 'px';
    selectionBox.style.top = chartArea.top + 'px';
    selectionBox.style.width = width + 'px';
    selectionBox.style.height = (chartArea.bottom - chartArea.top) + 'px';
    selectionBox.style.display = 'block';
  });
  
  canvas.addEventListener('mouseup', function(e) {
    if (!isDragging || !isAnnotationMode) return;
    
    isDragging = false;
    
    if (selectionBox) {
      selectionBox.style.display = 'none';
    }
    
    // Determine if it's a click or drag
    const rect = canvas.getBoundingClientRect();
    const endX = e.clientX - rect.left;
    const dragDistance = Math.abs(endX - dragStartX);
    
    if (dragDistance < 5) {
      // It's a click - create point marker
      openModalForPoint(dragStartTime);
    } else {
      // It's a drag - create range marker
      const canvasPos = Chart.helpers.getRelativePosition(e, currentChart);
      const xScale = currentChart.scales.x;
      dragEndTime = xScale.getValueForPixel(canvasPos.x);
      
      if (dragStartTime !== null && dragEndTime !== null) {
        openModalForRange(dragStartTime, dragEndTime);
      }
    }
  });
  
  canvas.addEventListener('mouseleave', function() {
    if (isDragging && selectionBox) {
      selectionBox.style.display = 'none';
    }
    isDragging = false;
  });
}

function openModalForPoint(timeInSeconds) {
  // Populate form untuk point marker
  document.getElementById('startTimeSeconds').value = timeInSeconds.toFixed(3);
  document.querySelector('input[name="markerType"][value="point"]').checked = true;
  document.getElementById('endTimeGroup').style.display = 'none';
  document.getElementById('endTimeSeconds').value = '';
  document.getElementById('annotationLabel').value = '';
  document.getElementById('annotationNotes').value = '';
  
  document.getElementById('annotationModal').style.display = 'flex';
}

function openModalForRange(startTime, endTime) {
  // Sort times
  const start = Math.min(startTime, endTime);
  const end = Math.max(startTime, endTime);
  
  // Populate form untuk range marker
  document.getElementById('startTimeSeconds').value = start.toFixed(3);
  document.getElementById('endTimeSeconds').value = end.toFixed(3);
  document.querySelector('input[name="markerType"][value="range"]').checked = true;
  document.getElementById('endTimeGroup').style.display = 'block';
  document.getElementById('annotationLabel').value = '';
  document.getElementById('annotationNotes').value = '';
  
  document.getElementById('annotationModal').style.display = 'flex';
}

function openModal(timeInSeconds) {
  openModalForPoint(timeInSeconds);
}

function closeModal() {
  document.getElementById('annotationModal').style.display = 'none';
  document.getElementById('annotationForm').reset();
}

async function saveAnnotation(e) {
  e.preventDefault();
  
  const markerType = document.querySelector('input[name="markerType"]:checked').value;
  const startTimeSeconds = parseFloat(document.getElementById('startTimeSeconds').value);
  const label = document.getElementById('annotationLabel').value;
  const notes = document.getElementById('annotationNotes').value;
  
  // Validasi input
  if (!label) {
    alert('‚ùå Label harus diisi!');
    return;
  }
  
  if (isNaN(startTimeSeconds) || startTimeSeconds < 0) {
    alert('‚ùå Waktu mulai tidak valid!');
    return;
  }
  
  const payload = {
    annotation: {
      start_time_seconds: startTimeSeconds,
      label: label,
      notes: notes || ''
    }
  };
  
  // Tambahkan end_time jika marker type adalah range
  if (markerType === 'range') {
    const endTimeSecondsInput = document.getElementById('endTimeSeconds').value;
    if (!endTimeSecondsInput) {
      alert('‚ùå Waktu akhir harus diisi untuk marker range!');
      return;
    }
    
    const endTimeSeconds = parseFloat(endTimeSecondsInput);
    if (isNaN(endTimeSeconds)) {
      alert('‚ùå Waktu akhir tidak valid!');
      return;
    }
    
    if (endTimeSeconds <= startTimeSeconds) {
      alert('‚ùå Waktu akhir harus lebih besar dari waktu mulai!');
      return;
    }
    
    payload.annotation.end_time_seconds = endTimeSeconds;
  }
  
  console.log('Saving annotation:', payload);
  
  try {
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
    if (!csrfToken) {
      alert('‚ùå CSRF token tidak ditemukan!');
      return;
    }
    
    const response = await fetch(`/recordings/${RECORDING_ID}/annotations`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify(payload)
    });
    
    let result;
    try {
      result = await response.json();
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      alert('‚ùå Server response tidak valid');
      return;
    }
    
    console.log('Server response:', response.status, result);
    
    if (response.ok) {
      closeModal();
      await fetchAnnotations();
      alert('‚úì Anotasi berhasil disimpan!');
    } else {
      const errorMsg = result.errors ? result.errors.join(', ') : (result.error || 'Gagal menyimpan anotasi');
      alert('‚ùå ' + errorMsg);
      console.error('Save error:', result);
    }
  } catch (error) {
    console.error('Error saving annotation:', error);
    alert('‚ùå Terjadi kesalahan saat menyimpan: ' + error.message);
  }
}

async function fetchAnnotations() {
  try {
    const response = await fetch(`/recordings/${RECORDING_ID}/annotations`);
    const data = await response.json();
    annotations = data;
    updateChartAnnotations();
  } catch (error) {
    console.error('Error fetching annotations:', error);
  }
}

function showAnnotationsList() {
  if (annotations.length === 0) {
    alert('Belum ada anotasi untuk recording ini.');
    return;
  }
  
  let html = '<div class="annotations-list-modal modal-overlay" style="display: flex;">';
  html += '<div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">';
  html += '<h3>Daftar Anotasi (' + annotations.length + ')</h3>';
  html += '<div style="margin-bottom: 16px;">';
  
  annotations.forEach((ann, idx) => {
    const startSeconds = ((new Date(ann.start_time).getTime() - START_TIME) / 1000).toFixed(3);
    const typeLabel = ann.marker_type === 'point' ? 'üìç Titik' : 'üìè Range';
    const typeColor = ann.marker_type === 'point' ? '#ff6384' : '#36a2eb';
    
    html += '<div style="border: 2px solid ' + typeColor + '; border-radius: 8px; padding: 12px; margin-bottom: 12px; background: white;">';
    html += '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">';
    html += '<div>';
    html += '<strong style="color: ' + typeColor + ';">' + typeLabel + ' - ' + ann.label + '</strong><br>';
    html += '<small style="color: #6c757d;">Waktu: ' + startSeconds + 's';
    
    if (ann.marker_type === 'range') {
      const endSeconds = ((new Date(ann.end_time).getTime() - START_TIME) / 1000).toFixed(3);
      html += ' ‚Üí ' + endSeconds + 's (durasi: ' + ann.duration_seconds + 's)';
    }
    
    html += '</small><br>';
    if (ann.notes) {
      html += '<small style="color: #495057;">' + ann.notes + '</small><br>';
    }
    if (ann.created_by) {
      html += '<small style="color: #6c757d;">Oleh: ' + ann.created_by.name + '</small>';
    }
    html += '</div>';
    html += '<button onclick="deleteAnnotation(' + ann.id + ')" class="btn btn-sm" style="background: #dc3545; color: white; padding: 4px 8px;">Hapus</button>';
    html += '</div>';
    html += '</div>';
  });
  
  html += '</div>';
  html += '<div class="form-actions"><button onclick="closeAnnotationsList()" class="btn btn-secondary">Tutup</button></div>';
  html += '</div></div>';
  
  document.body.insertAdjacentHTML('beforeend', html);
}

function closeAnnotationsList() {
  const modal = document.querySelector('.annotations-list-modal');
  if (modal) modal.remove();
}

async function deleteAnnotation(annotationId) {
  if (!confirm('Yakin ingin menghapus anotasi ini?')) return;
  
  try {
    const response = await fetch(`/recordings/${RECORDING_ID}/annotations/${annotationId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    });
    
    if (response.ok) {
      alert('‚úì Anotasi berhasil dihapus');
      closeAnnotationsList();
      fetchAnnotations();
    } else {
      alert('‚ùå Gagal menghapus anotasi');
    }
  } catch (error) {
    console.error('Error deleting annotation:', error);
    alert('‚ùå Terjadi kesalahan');
  }
}

function updateChartAnnotations() {
  if (!currentChart) return;
  
  const annotationConfigs = {};
  
  annotations.forEach((ann, index) => {
    const startSeconds = (new Date(ann.start_time).getTime() - START_TIME) / 1000;
    
    if (ann.marker_type === 'point') {
      // Marker titik - garis vertikal merah
      annotationConfigs['point_' + ann.id] = {
        type: 'line',
        xMin: startSeconds,
        xMax: startSeconds,
        borderColor: 'rgb(255, 99, 132)',
        borderWidth: 2,
        borderDash: [5, 5],
        label: {
          display: true,
          content: ann.label,
          position: 'start',
          backgroundColor: 'rgba(255, 99, 132, 0.8)',
          color: 'white',
          font: { size: 10, weight: 'bold' },
          padding: 4
        }
      };
    } else {
      // Marker range - box dengan highlight
      const endSeconds = (new Date(ann.end_time).getTime() - START_TIME) / 1000;
      
      annotationConfigs['range_' + ann.id] = {
        type: 'box',
        xMin: startSeconds,
        xMax: endSeconds,
        backgroundColor: 'rgba(54, 162, 235, 0.15)',
        borderColor: 'rgb(54, 162, 235)',
        borderWidth: 2,
        label: {
          display: true,
          content: ann.label + ' (' + ann.duration_seconds + 's)',
          position: 'center',
          backgroundColor: 'rgba(54, 162, 235, 0.9)',
          color: 'white',
          font: { size: 10, weight: 'bold' },
          padding: 4
        }
      };
    }
  });
  
  currentChart.options.plugins.annotation.annotations = annotationConfigs;
  currentChart.update('none');
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function resetZoom() {
  if (currentChart) {
    currentChart.resetZoom();
    currentChart.scales.x.min = 0;
    currentChart.scales.x.max = 10;
    currentChart.update();
    
    // Clear cache and refetch initial data
    dataCache = {};
    fetchDataBuffered(START_TIME, START_TIME + INITIAL_WINDOW + BUFFER_SIZE);
  }
}

// Auto-refresh for active recordings
let autoRefreshInterval = null;

function startAutoRefresh() {
  console.log('Starting auto-refresh for active recording');
  
  // Refresh every 10 seconds
  autoRefreshInterval = setInterval(async function() {
    console.log('Auto-refreshing data...');
    
    // Clear cache to force fresh data
    dataCache = {};
    
    // Get current view window
    const {min, max} = currentChart.scales.x;
    const visibleStartMs = START_TIME + (min * 1000);
    const visibleEndMs = START_TIME + (max * 1000);
    
    // Fetch latest data for current view
    await fetchDataBuffered(visibleStartMs, visibleEndMs);
    
    // Check if recording is still active
    try {
      const response = await fetch(`/api/recordings/${RECORDING_ID}`);
      const result = await response.json();
      
      if (result.data.recording.status !== 'recording') {
        console.log('Recording completed, stopping auto-refresh');
        stopAutoRefresh();
        
        // Show notification
        showNotification('Recording selesai! Data lengkap sudah tersedia.', 'success');
        
        // Reload page to show complete data
        setTimeout(() => location.reload(), 2000);
      } else if (result.data.recording.total_batches > 0 && !HAS_DATA) {
        // Data baru tersedia, reload page
        console.log('New data available, reloading page');
        location.reload();
      }
    } catch (error) {
      console.error('Error checking recording status:', error);
    }
  }, 10000); // 10 seconds
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 16px 24px;
    background: ${type === 'success' ? '#28a745' : '#667eea'};
    color: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 10000;
    animation: slideIn 0.3s ease;
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOut 0.3s ease';
    setTimeout(() => notification.remove(), 300);
  }, 5000);
}
</script>

<style>
@keyframes slideIn {
  from {
    transform: translateX(400px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(400px);
    opacity: 0;
  }
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(1.1); }
}

.rotating {
  display: inline-block;
  animation: rotate 2s linear infinite;
}

.pulse-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  background: #28a745;
  border-radius: 50%;
  margin-right: 8px;
  animation: pulse 1.5s ease-in-out infinite;
}

.auto-refresh-indicator {
  display: inline-flex;
  align-items: center;
  margin-top: 16px;
  padding: 8px 16px;
  background: rgba(40, 167, 69, 0.1);
  border-radius: 20px;
  font-size: 14px;
  color: #28a745;
}

.no-data-placeholder {
  position: relative;
  min-height: 400px;
}

.placeholder-chart {
  opacity: 0.3;
}

.overlay-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  z-index: 10;
  background: white;
  padding: 32px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  max-width: 600px;
  width: 90%;
}

.overlay-message .status-icon {
  font-size: 64px;
  margin-bottom: 16px;
}

.overlay-message h3 {
  margin: 0 0 16px 0;
  color: #2c3e50;
}

.status-badge {
  display: inline-block;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
}

.status-badge.no_data {
  background: #fff3cd;
  color: #856404;
}

.status-badge.incomplete {
  background: #d1ecf1;
  color: #0c5460;
}

.status-badge.partial {
  background: #f8d7da;
  color: #721c24;
}

.recording-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.recording-header {
  background: white;
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.recording-header h1 {
  color: #2c3e50;
  margin-bottom: 16px;
}

.recording-info p {
  margin: 4px 0;
  color: #7f8c8d;
}

.recording-content {
  display: grid;
  gap: 24px;
}

.chart-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.chart-section h2 {
  color: #2c3e50;
  margin-bottom: 20px;
}

.chart-info {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
  padding: 16px;
  background: #f8f9fa;
  border-radius: 8px;
}

.chart-info p {
  margin: 0;
  color: #495057;
}

.chart-info strong {
  color: #2c3e50;
}

.no-data-message {
  text-align: center;
  padding: 48px 24px;
  background: #f8f9fa;
  border-radius: 8px;
  color: #6c757d;
}

.no-data-message.error-state {
  background: #fff3cd;
  border: 2px solid #ffc107;
}

.no-data-message .status-icon {
  margin-bottom: 16px;
}

.no-data-message h3 {
  font-size: 18px;
  margin-bottom: 24px;
  color: #495057;
}

.no-data-message.error-state h3 {
  color: #856404;
}

.error-details, .info-details {
  text-align: left;
  max-width: 700px;
  margin: 0 auto;
  padding: 20px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.error-details p, .info-details p {
  margin: 12px 0;
  font-size: 14px;
}

.error-details ul, .info-details ul {
  margin: 8px 0 16px 20px;
  padding: 0;
  list-style: disc;
}

.error-details li, .info-details li {
  margin: 6px 0;
  color: #495057;
  font-size: 14px;
}

.error-details strong {
  color: #2c3e50;
  font-size: 15px;
}

.badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
}

.badge-completed {
  background: #d4edda;
  color: #155724;
}

.badge-recording {
  background: #d1ecf1;
  color: #0c5460;
}

.badge-failed {
  background: #f8d7da;
  color: #721c24;
}

.action-hint {
  margin-top: 20px;
  padding: 16px;
  background: #e7f3ff;
  border-left: 4px solid #2196f3;
  border-radius: 4px;
}

.action-hint p {
  margin: 8px 0;
}

.action-hint strong {
  color: #1976d2;
}

.chart-container {
  position: relative;
  height: 400px;
  margin-bottom: 20px;
}

.chart-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.interpretation-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.interpretation-section h2 {
  color: #2c3e50;
  margin-bottom: 20px;
}

.interpretation-card {
  background: #f8f9fa;
  border-radius: 8px;
  padding: 20px;
}

.doctor-info {
  color: #3498db;
  font-weight: 500;
  margin-bottom: 16px;
}

.interpretation-item {
  margin-bottom: 20px;
}

.interpretation-item h3 {
  color: #2c3e50;
  margin-bottom: 8px;
  font-size: 16px;
}

.interpretation-item p {
  color: #7f8c8d;
  line-height: 1.6;
}

.add-interpretation-section {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.add-interpretation-section h2 {
  color: #2c3e50;
  margin-bottom: 20px;
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  color: #2c3e50;
  font-weight: 500;
}

.form-control {
  width: 100%;
  padding: 12px;
  border: 2px solid #e1e8ed;
  border-radius: 8px;
  font-size: 14px;
  transition: border-color 0.3s ease;
}

.form-control:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.waiting-interpretation {
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  border-radius: 8px;
  padding: 20px;
  text-align: center;
  color: #856404;
}

.recording-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 24px;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  text-decoration: none;
  display: inline-block;
  transition: all 0.3s ease;
}

.btn-sm {
  padding: 8px 16px;
  font-size: 12px;
}

.btn-primary {
  background: #667eea;
  color: white;
}

.btn-primary:hover {
  background: #5a6fd8;
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

.btn-secondary:hover {
  background: #5a6268;
}

.btn-outline {
  background: transparent;
  color: #667eea;
  border: 2px solid #667eea;
}

.btn-outline:hover {
  background: #667eea;
  color: white;
}

.btn-success {
  background: #28a745;
  color: white;
}

.btn-success:hover {
  background: #218838;
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 24px;
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: #2c3e50;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
}
</style>